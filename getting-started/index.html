<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><html lang="en"><head><title>Getting Started</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="icon" href="../assets/piggu.png"><link rel="stylesheet" href="../assets/index.css"></head><body><header><a href="https://github.com/fortunejs/fortune" id="corner"><span>Fork on</span> GitHub</a> <a href="../"><img src="../assets/piggu.svg" alt="Piggu" class="emblem"></a> <a href="../"><img src="../assets/fortune_type.svg" alt="Fortune.js" class="logo-type"></a><nav><a href="../getting-started/">Getting Started</a><!--
        --><a href="../api/">API Reference</a><!--
        --><a href="../plugins/">Plugins</a><!--
        --><a href="../changelog/">Changelog</a></nav></header><article><h1>Getting Started</h1><p>The first concern of Fortune.js is data modeling, which is structured as record types. Fields may be either a type or link field. A typed field may belong to some of the JavaScript and Node.js native types: <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Object</code>, <code>Array</code>, or <code>Buffer</code>. A link field establishes a reference to an ID belonging to a record, and its type is determined by the Adapter. For example:</p><pre><code class="lang-js">const fortune = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fortune'</span>)

const store = fortune({
  user: {
    name: { <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> },
    password: { <span class="hljs-keyword">type</span>: Buffer },
    salt: { <span class="hljs-keyword">type</span>: Buffer },
    <span class="hljs-keyword">group</span>: { <span class="hljs-keyword">link</span>: <span class="hljs-string">'group'</span>, inverse: <span class="hljs-string">'users'</span>, isArray: <span class="hljs-literal">true</span> }
  },
  <span class="hljs-keyword">group</span>: {
    name: { <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> },
    users: { <span class="hljs-keyword">link</span>: <span class="hljs-string">'user'</span>, inverse: <span class="hljs-string">'group'</span>, isArray: <span class="hljs-literal">true</span> }
  }
})
</code></pre><p>This defines a <code>user</code> record type that has a link field to the <code>group</code> type. By default, link fields are to-one, unless <code>isArray</code> is specified. In this example, there is a many-to-many relationship between a user and a group. The <code>inverse</code> field specifies a corresponding field on the linked type, so that any update to either field will affect the other (two-way binding). If an inverse is not specified, an internal field will be created automatically.</p><h2 id="transform-functions">Transform Functions<a class="anchor" href="#transform-functions" title="Link to this section “Transform Functions”">#</a></h2><p>Transform functions isolate business logic. An input and output transform function may be defined per record type. Transform functions accept at least two arguments, the <code>context</code> object, the record, and optionally the <code>update</code> object for an <code>update</code> request. The method of an input transform may be any method except <code>find</code>, and an output transform may be applied on all methods.</p><p>The return value of an input transform function determines what gets persisted, and it should be safe to mutate any of its arguments. It may return either the value or a Promise, or throw an error. For example, an input transform function for a record may look like this:</p><pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">input</span> <span class="hljs-params">(context, record, update)</span> </span>{
  <span class="hljs-comment">// If it's a create request, return the record.</span>
  <span class="hljs-keyword">if</span> (context.request.method === <span class="hljs-string">'create'</span>) <span class="hljs-keyword">return</span> record

  <span class="hljs-comment">// If the update argument exists, it's an update request.</span>
  <span class="hljs-keyword">if</span> (update) <span class="hljs-keyword">return</span> update

  <span class="hljs-comment">// Otherwise, it's a delete request and the return value doesn't matter.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}
</code></pre><p>An output transform function may only return a record or Promise that resolves to a record, or throw an error. It should be safe to mutate any of its arguments.</p><pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">output</span> (<span class="hljs-params">context, record</span>) </span>{
  record.accessedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
  <span class="hljs-keyword">return</span> record
})
</code></pre><p>Based on whether or not the resolved record is different from what was passed in, serializers may decide not show the resolved record of the output transform for update and delete requests.</p><h2 id="configuration">Configuration<a class="anchor" href="#configuration" title="Link to this section “Configuration”">#</a></h2><p>Fortune.js comes with defaults to work out of the box, but they are probably not suitable for real world applications. Consult the <a href="http://fortunejs.com/plugins/">plugins page</a> for more information.</p></article><footer><p>&copy; 2016 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></p><p>福</p></footer></body></html>