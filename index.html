<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><meta charset="utf-8"><title>Fortune.js</title><meta name="description" content="A library for managing structured data in Node.js and web browsers."><meta name="keywords" content="adapter,api,application,data,middleware,serializer,transform"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="./assets/piggu.png"><link rel="stylesheet" href="./assets/index.css"><header><a href="https://github.com/fortunejs/fortune" id="corner"><span>Fork on </span>GitHub</a> <a href="./"><img src="./assets/piggu.svg" alt="Piggu" class="emblem"></a><a href="./"><img src="./assets/fortune_type.svg" alt="Fortune.js" class="logo-type"></a><nav><a href="./getting-started/">Getting Started</a><!--
    --><a href="./api/">API Reference</a><!--
    --><a href="./plugins/">Plugins</a><!--
    --><a href="./changelog/">Changelog</a></nav></header><article><p class="intro">Fortune.js is a library for managing structured data in Node.js and web browsers. It consists of a data abstraction layer and networking functions.</p><p>The latest version is <strong>4.0.1</strong>, get it from <code>npm</code>:</p><pre class="install"><code>npm install <span class="hljs-literal">fortune</span> <span class="hljs-string">--save</span></code></pre><h4 id="synopsis">Synopsis<a class="anchor" href="#synopsis" title="Link to this section “Synopsis”">#</a></h4><p>Fortune.js implements a data abstraction layer, and also includes networking functions, specific for Node.js and web browsers. There are a variety of use cases for Fortune.js, for example:</p><ul><li>A server-side implementation of a web service over HTTP. The included HTTP implementation provides a basis for implementing application-level protocols, including media types such as HTML (included), <a href="http://micro-api.org">Micro API</a> and <a href="http://jsonapi.org">JSON API</a>, and covers standard input formats such as URL encoded and form data.</li><li>A persistence layer in web browsers. Under the hood, it uses IndexedDB, Web Worker, and MessagePack to achieve high performance for persisting structured data.</li><li>An abstraction layer for working with multiple databases. Write the same logic which will work across multiple adapters.</li><li>Real-time web applications. Fortune.js includes its own <a href="http://fortunejs.com/api/#fortune.net-ws">wire protocol</a> based on WebSocket and MessagePack.</li></ul><h2 id="example">Example<a class="anchor" href="#example" title="Link to this section “Example”">#</a></h2><p>The only required input is record type definitions. Here&#39;s a model of a basic micro-blogging service:</p><pre><code class="lang-js">const fortune = require(<span class="hljs-string">'fortune'</span>)

const store = fortune({
<span class="hljs-symbol">  user:</span> {
<span class="hljs-symbol">    name:</span> { <span class="hljs-string">type:</span> String },

    <span class="hljs-comment">// Following and followers are inversely related (many-to-many).</span>
<span class="hljs-symbol">    following:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'followers'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> },
<span class="hljs-symbol">    followers:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'following'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> },

    <span class="hljs-comment">// Many-to-one relationship of user posts to post author.</span>
<span class="hljs-symbol">    posts:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'post'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'author'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> }
  },
<span class="hljs-symbol">  post:</span> {
<span class="hljs-symbol">    message:</span> { <span class="hljs-string">type:</span> String },

    <span class="hljs-comment">// One-to-many relationship of post author to user posts.</span>
<span class="hljs-symbol">    author:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'posts'</span> }
  }
})
</code></pre><p>By default, the data is persisted in memory. There are adapters for databases such as <a href="https://github.com/fortunejs/fortune-mongodb">MongoDB</a>, <a href="https://github.com/fortunejs/fortune-postgres">Postgres</a>, and <a href="https://github.com/fortunejs/fortune-nedb">NeDB</a>. To make a request internally:</p><pre><code class="lang-js"><span class="hljs-selector-tag">store</span><span class="hljs-selector-class">.request</span>({
  <span class="hljs-attribute">type</span>: <span class="hljs-string">'user'</span>,
  method: <span class="hljs-string">'create'</span>,
  payload: [ { name: <span class="hljs-string">'John Doe'</span> }, { <span class="hljs-attribute">name</span>: <span class="hljs-string">'Jane Doe'</span> } ]
})
</code></pre><p>The first call to <code>request</code> will trigger a connection to the data store, and it returns the result as a Promise.</p><p>Then let&#39;s add a HTTP server:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> http = require(<span class="hljs-string">'http'</span>)

<span class="hljs-comment">// The `fortune.net.http` helper function returns a listener function which</span>
<span class="hljs-comment">// does content negotiation, and maps the internal response to a HTTP response.</span>
<span class="hljs-keyword">const</span> server = http.createServer(fortune.net.http(store))

store.<span class="hljs-built_in">connect</span>().then(() =&gt; server.<span class="hljs-built_in">listen</span>(<span class="hljs-number">1337</span>))
</code></pre><p>This yields an <em>ad hoc</em> JSON over HTTP API, as well as a HTML interface for humans. There are serializers for <a href="https://github.com/fortunejs/fortune-micro-api">Micro API</a> (JSON-LD) and <a href="https://github.com/fortunejs/fortune-json-api">JSON API</a>, which also accept HTTP parameters. In addition, Fortune.js implements a <a href="http://fortunejs.com/api/#fortune.net-ws">wire protocol</a> based on <a href="https://developer.mozilla.org/docs/Web/API/WebSockets_API">WebSocket</a> and <a href="http://msgpack.org">MessagePack</a>.</p><p>See the <a href="http://fortunejs.com/plugins/">plugins page</a> for more details.</p><h2 id="features-and-non-features">Features and Non-Features<a class="anchor" href="#features-and-non-features" title="Link to this section “Features and Non-Features”">#</a></h2><ul><li>Type validations, with support for custom types.</li><li>Application-level denormalized inverse relationships.</li><li>Dereferencing relationships in a single request.</li><li><em>Isomorphic</em>, backed by IndexedDB in web browsers, including a built-in wire protocol for data synchronization.</li><li><strong>No</strong> active record pattern, just plain data objects.</li><li><strong>No</strong> coupling with network protocol, they are treated as external I/O.</li></ul><h2 id="requirements">Requirements<a class="anchor" href="#requirements" title="Link to this section “Requirements”">#</a></h2><p>Fortune.js is written in ECMAScript 5.1 syntax, with some ECMAScript 6 additions.</p><ul><li><strong>Promise</strong> (ES6): not supported in IE, supported in Edge. Bring your own implementation (optional).</li><li><strong>WeakMap</strong> (ES6): supported in IE11+, Edge. Polyfills exist, but they have their shortcomings since it must be implemented natively.</li></ul></article><footer><p>&copy; 2016 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></p><p>福</p></footer>